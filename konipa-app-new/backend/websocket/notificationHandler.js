const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const { User } = require('../models');
const notificationService = require('../services/NotificationService');

class NotificationWebSocketHandler {
  constructor(server) {
    this.wss = new WebSocket.Server({ 
      server, 
      path: '/ws/notifications',
      verifyClient: this.verifyClient.bind(this),
      perMessageDeflate: false // D√©sactiver la compression pour √©viter les erreurs
    });
    
    this.clients = new Map(); // clientId -> client info
    this.userSockets = new Map(); // userId -> Set of clientIds
    this.roleSubscriptions = new Map(); // role -> Set of clientIds
    
    this.setupWebSocketServer();
    this.setupNotificationServiceIntegration();
    
    console.log('[WEBSOCKET] Serveur WebSocket de notifications initialis√© sur /ws/notifications');
  }

  verifyClient(info) {
    // Optionnel: v√©rification pr√©liminaire de l'origine
    return true;
  }

  setupWebSocketServer() {
    this.wss.on('connection', (ws, req) => {
      const clientId = this.generateClientId();
      console.log(`üîç [NOTIFICATIONS] Nouvelle connexion: ${clientId} depuis ${req.socket.remoteAddress}`);
      
      // Stocker les informations du client
      this.clients.set(clientId, {
        ws,
        id: clientId,
        connectedAt: new Date(),
        lastPing: new Date(),
        userId: null,
        userRole: null,
        authenticated: false,
        subscriptions: new Set()
      });
        
        console.log(`üîç [NOTIFICATIONS] Client ${clientId} ajout√©, total clients: ${this.clients.size}`);

      // Envoyer un message de bienvenue
      this.sendToClient(clientId, {
        type: 'connection_established',
        clientId,
        timestamp: new Date().toISOString(),
        message: 'Connexion WebSocket √©tablie pour les notifications'
      });

      // G√©rer les messages du client
      ws.on('message', (message) => {
        console.log('üîç [NOTIFICATIONS] Message re√ßu:', message.toString());
        try {
          const data = JSON.parse(message);
          console.log('üîç [NOTIFICATIONS] Message pars√©:', JSON.stringify(data));
          this.handleClientMessage(clientId, data);
        } catch (error) {
          console.error(`[WEBSOCKET] Erreur parsing message du client ${clientId}:`, error);
          this.sendToClient(clientId, {
            type: 'error',
            message: 'Format de message invalide'
          });
        }
      });

      // G√©rer la d√©connexion
      ws.on('close', (code, reason) => {
        console.log(`üîç [NOTIFICATIONS] Connexion ferm√©e: ${clientId}, code: ${code}, raison: ${reason}`);
        this.removeClient(clientId);
      });

      // G√©rer les erreurs
      ws.on('error', (error) => {
        console.error(`üîç [NOTIFICATIONS] Erreur WebSocket: ${clientId}`, error.message || error);
        this.removeClient(clientId);
      });

      // Ping/Pong pour maintenir la connexion
      const pingInterval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.ping();
          const client = this.clients.get(clientId);
          if (client) {
            client.lastPing = new Date();
          }
        } else {
          clearInterval(pingInterval);
        }
      }, 30000);

      ws.on('pong', () => {
        const client = this.clients.get(clientId);
        if (client) {
          client.lastPing = new Date();
        }
      });
    });
  }

  setupNotificationServiceIntegration() {
    // TODO: Int√©grer avec le service de notifications existant
    // Le NotificationService n'est pas un EventEmitter, il faut revoir l'int√©gration
    console.log('[WEBSOCKET] Int√©gration NotificationService temporairement d√©sactiv√©e');
    
    // notificationService.on('notification_sent', (data) => {
    //   this.handleNotificationSent(data);
    // });

    // notificationService.on('notification_broadcast', (data) => {
    //   this.handleNotificationBroadcast(data);
    // });

    // notificationService.on('role_notification', (data) => {
    //   this.handleRoleNotification(data);
    // });

    console.log('[WEBSOCKET] Int√©gration avec le service de notifications configur√©e');
  }

  generateClientId() {
    return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async handleClientMessage(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client) return;

    switch (data.type) {
      case 'authenticate':
        await this.handleAuthentication(clientId, data);
        break;
        
      case 'subscribe_role':
        this.handleRoleSubscription(clientId, data);
        break;
        
      case 'unsubscribe_role':
        this.handleRoleUnsubscription(clientId, data);
        break;
        
      case 'get_unread_count':
        await this.sendUnreadCount(clientId);
        break;
        
      case 'mark_as_read':
        await this.handleMarkAsRead(clientId, data);
        break;
        
      case 'mark_all_as_read':
        await this.handleMarkAllAsRead(clientId);
        break;
        
      case 'get_notifications':
        await this.sendNotifications(clientId, data);
        break;
        
      case 'ping':
        this.sendToClient(clientId, {
          type: 'pong',
          timestamp: new Date().toISOString()
        });
        break;
        
      default:
        this.sendToClient(clientId, {
          type: 'error',
          message: `Type de message non support√©: ${data.type}`
        });
    }
  }

  async handleAuthentication(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client) return;

    try {
      // V√©rifier le token JWT
      const decoded = jwt.verify(data.token, process.env.JWT_SECRET);
      
      // R√©cup√©rer les informations utilisateur
      const user = await User.findByPk(decoded.id, {
        attributes: ['id', 'email', 'role', 'first_name', 'last_name']
      });

      if (!user) {
        this.sendToClient(clientId, {
          type: 'authentication_failed',
          message: 'Utilisateur non trouv√©'
        });
        return;
      }

      // Mettre √† jour les informations du client
      client.userId = user.id;
      client.userRole = user.role;
      client.authenticated = true;

      // Ajouter √† la map des utilisateurs
      if (!this.userSockets.has(user.id)) {
        this.userSockets.set(user.id, new Set());
      }
      this.userSockets.get(user.id).add(clientId);

      // S'abonner automatiquement aux notifications de son r√¥le
      this.subscribeToRole(clientId, user.role);

      // Int√©grer avec le service de notifications existant
      notificationService.addClient(user.id, client.ws);

      this.sendToClient(clientId, {
        type: 'authentication_success',
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          name: `${user.first_name} ${user.last_name}`
        },
        timestamp: new Date().toISOString()
      });

      // Envoyer le nombre de notifications non lues
      await this.sendUnreadCount(clientId);

      console.log(`[WEBSOCKET] Client ${clientId} authentifi√©: ${user.email} (${user.role})`);
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur d'authentification pour ${clientId}:`, error);
      this.sendToClient(clientId, {
        type: 'authentication_failed',
        message: 'Token invalide'
      });
    }
  }

  subscribeToRole(clientId, role) {
    const client = this.clients.get(clientId);
    if (!client) return;

    client.subscriptions.add(role);
    
    if (!this.roleSubscriptions.has(role)) {
      this.roleSubscriptions.set(role, new Set());
    }
    this.roleSubscriptions.get(role).add(clientId);

    console.log(`[WEBSOCKET] Client ${clientId} abonn√© au r√¥le: ${role}`);
  }

  handleRoleSubscription(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client || !client.authenticated) {
      this.sendToClient(clientId, {
        type: 'error',
        message: 'Authentification requise'
      });
      return;
    }

    const { role } = data;
    if (!role) {
      this.sendToClient(clientId, {
        type: 'error',
        message: 'R√¥le requis pour l\'abonnement'
      });
      return;
    }

    this.subscribeToRole(clientId, role);
    
    this.sendToClient(clientId, {
      type: 'subscription_success',
      role,
      timestamp: new Date().toISOString()
    });
  }

  handleRoleUnsubscription(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client) return;

    const { role } = data;
    if (!role) return;

    client.subscriptions.delete(role);
    
    if (this.roleSubscriptions.has(role)) {
      this.roleSubscriptions.get(role).delete(clientId);
      if (this.roleSubscriptions.get(role).size === 0) {
        this.roleSubscriptions.delete(role);
      }
    }

    this.sendToClient(clientId, {
      type: 'unsubscription_success',
      role,
      timestamp: new Date().toISOString()
    });

    console.log(`[WEBSOCKET] Client ${clientId} d√©sabonn√© du r√¥le: ${role}`);
  }

  async sendUnreadCount(clientId) {
    const client = this.clients.get(clientId);
    if (!client || !client.authenticated) return;

    try {
      const count = await notificationService.getUnreadCount(client.userId);
      this.sendToClient(clientId, {
        type: 'unread_count',
        count,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur lors de l'envoi du compteur non lu:`, error);
    }
  }

  async handleMarkAsRead(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client || !client.authenticated) return;

    try {
      const { notificationId } = data;
      // Ici vous pourriez impl√©menter la logique pour marquer une notification sp√©cifique comme lue
      // Pour l'instant, on utilise la m√©thode existante du service
      
      this.sendToClient(clientId, {
        type: 'mark_read_success',
        notificationId,
        timestamp: new Date().toISOString()
      });

      // Mettre √† jour le compteur
      await this.sendUnreadCount(clientId);
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur lors du marquage comme lu:`, error);
    }
  }

  async handleMarkAllAsRead(clientId) {
    const client = this.clients.get(clientId);
    if (!client || !client.authenticated) return;

    try {
      const updatedCount = await notificationService.markAllAsRead(client.userId);
      
      this.sendToClient(clientId, {
        type: 'mark_all_read_success',
        updatedCount,
        timestamp: new Date().toISOString()
      });

      // Le service de notifications se charge d√©j√† d'envoyer la mise √† jour en temps r√©el
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur lors du marquage de toutes comme lues:`, error);
    }
  }

  async sendNotifications(clientId, data) {
    const client = this.clients.get(clientId);
    if (!client || !client.authenticated) return;

    try {
      const { page = 1, limit = 20, type = null } = data;
      
      // Ici vous pourriez impl√©menter une m√©thode dans le service de notifications
      // pour r√©cup√©rer les notifications pagin√©es
      
      this.sendToClient(clientId, {
        type: 'notifications_list',
        notifications: [], // √Ä impl√©menter
        pagination: {
          page,
          limit,
          total: 0
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur lors de l'envoi des notifications:`, error);
    }
  }

  // M√©thodes pour g√©rer les √©v√©nements du service de notifications
  handleNotificationSent(data) {
    const { userId, notification } = data;
    
    if (this.userSockets.has(userId)) {
      const clientIds = this.userSockets.get(userId);
      clientIds.forEach(clientId => {
        this.sendToClient(clientId, {
          type: 'new_notification',
          notification,
          timestamp: new Date().toISOString()
        });
      });
    }
  }

  handleNotificationBroadcast(data) {
    const { userIds, notification } = data;
    
    userIds.forEach(userId => {
      if (this.userSockets.has(userId)) {
        const clientIds = this.userSockets.get(userId);
        clientIds.forEach(clientId => {
          this.sendToClient(clientId, {
            type: 'new_notification',
            notification,
            timestamp: new Date().toISOString()
          });
        });
      }
    });
  }

  handleRoleNotification(data) {
    const { roles, notification } = data;
    
    roles.forEach(role => {
      if (this.roleSubscriptions.has(role)) {
        const clientIds = this.roleSubscriptions.get(role);
        clientIds.forEach(clientId => {
          this.sendToClient(clientId, {
            type: 'role_notification',
            notification,
            role,
            timestamp: new Date().toISOString()
          });
        });
      }
    });
  }

  sendToClient(clientId, message) {
    const client = this.clients.get(clientId);
    if (!client || client.ws.readyState !== WebSocket.OPEN) {
      return false;
    }

    try {
      client.ws.send(JSON.stringify(message));
      return true;
    } catch (error) {
      console.error(`[WEBSOCKET] Erreur envoi message au client ${clientId}:`, error);
      this.removeClient(clientId);
      return false;
    }
  }

  broadcastToRole(role, message) {
    if (!this.roleSubscriptions.has(role)) return 0;
    
    const clientIds = this.roleSubscriptions.get(role);
    let sentCount = 0;
    
    clientIds.forEach(clientId => {
      if (this.sendToClient(clientId, message)) {
        sentCount++;
      }
    });
    
    return sentCount;
  }

  broadcastToAllAuthenticated(message) {
    let sentCount = 0;
    
    this.clients.forEach((client, clientId) => {
      if (client.authenticated && this.sendToClient(clientId, message)) {
        sentCount++;
      }
    });
    
    return sentCount;
  }

  removeClient(clientId) {
    const client = this.clients.get(clientId);
    if (!client) return;

    // Supprimer des abonnements par r√¥le
    client.subscriptions.forEach(role => {
      if (this.roleSubscriptions.has(role)) {
        this.roleSubscriptions.get(role).delete(clientId);
        if (this.roleSubscriptions.get(role).size === 0) {
          this.roleSubscriptions.delete(role);
        }
      }
    });

    // Supprimer de la map des utilisateurs
    if (client.userId && this.userSockets.has(client.userId)) {
      this.userSockets.get(client.userId).delete(clientId);
      if (this.userSockets.get(client.userId).size === 0) {
        this.userSockets.delete(client.userId);
      }
    }

    // Supprimer du service de notifications
    if (client.userId && client.ws) {
      notificationService.removeClient(client.userId, client.ws);
    }

    // Supprimer de la map des clients
    this.clients.delete(clientId);
  }

  // M√©thodes utilitaires
  getConnectedUsersCount() {
    return this.userSockets.size;
  }

  getConnectedClientsCount() {
    return this.clients.size;
  }

  getRoleSubscriptionsCount() {
    const counts = {};
    this.roleSubscriptions.forEach((clientIds, role) => {
      counts[role] = clientIds.size;
    });
    return counts;
  }

  getStats() {
    return {
      connectedUsers: this.getConnectedUsersCount(),
      connectedClients: this.getConnectedClientsCount(),
      roleSubscriptions: this.getRoleSubscriptionsCount(),
      timestamp: new Date().toISOString()
    };
  }
}

module.exports = NotificationWebSocketHandler;